


# 分布式事务


## CAP

C: 一致性，  等同于所有节点访问同一份最新的数据副本
A: 可用性    系统提供的服务一直处于可用的状态，每次请求都能获得正确的响应。
P: 分区容错性    以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择	（指系统在遇到【某节点】故障或【网络分区】故障的时候，仍然能够对外提供服务。）


对于分布式系统来说，分区容错性是一定需要的，因此可分为CP,与AP


CAP定理指出，分布式系统不能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance），只能满足其中两项。下面我会从不同问题的角度解释CAP定理在您描述的系统中的体现。

假设系统架构如下：
服务层：三台机器提供服务，都连接到数据库。
数据库层：一主一备的数据库架构，其中一个数据库充当主数据库，另一个为备份。
系统出现问题的情况：
网络分区 (P)：
假设服务层与数据库层之间发生网络分割，导致一部分或全部服务机器无法访问主数据库。

可用性优先（AP）：如果系统选择保证可用性，那么它可能允许服务层向用户显示过时或不完整的数据，或者利用备份数据库来响应请求。这样虽然用户体验不受影响，但这可能牺牲了一致性，因为备份数据库可能不包含最新的写操作数据。
一致性优先（CP）：如果系统选择保证一致性，那么在网络分区期间，服务可能因等待数据库恢复到一致状态而完全不可用，或者仅对能够确保读写一致性的部分服务请求提供可用性。
数据库故障：
如果主数据库发生故障，系统可能会自动切换到备份数据库以维护服务。

可用性优先（AP）：通过快速切换到备份数据库，服务能够继续提供，用户可能不会注意到后端的变动。但是在切换过程中，可能会有一段时间是在没有写数据的能力的情况下运行（写请求可以被拒绝或延后处理），这段时间内一致性也许会降低。
一致性优先（CP）：在保证数据完全同步到备份数据库之前，服务可能会暂时不可用，直到可以确保所有读写操作都是一致的。
服务层负载增加：
当服务层的负载达到顶峰时，为了保持服务的响应速度，可能会对数据的一致性做出妥协。

可用性优先（AP）：系统可能会允许从备份数据库读取数据，或者接受数据的可能不一致，以此来保持高响应性。对用户来说，服务依旧是快速可用的，但是可能会看到过时或不一致的数据。
一致性优先（CP）：系统可能决定只响应那些能够保证数据一致性的请求，这可能导致响应时间较长，或在高负载下拒绝服务一部分请求。
结论：
上述示例表明，分布式系统设计的权衡点在于，当面临网络分区或其它故障的时候，是选择保持服务的一致性，还是保持服务的可用性。在现实中，分布式系统通常会采用某种形式的妥协，例如通过最终一致性或者调整一致性级别来平衡CAP定理各属性之间的关系。 设计者需要根据具体业务需求、系统容错性和用户体验来决定在CAP定理的决策上做何种妥协。



## 分布式事务

https://dtm.pub/practice/theory.html#%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA

在分布式事务进行的过程中，一致性是无法得到保证的，但是分布式事务完成之后，一致性是没问题的，严格遵守的。因此我们将分布式事务方案称为最终一致性方案，这个最终一致性，与CAP中的最终一致性用了同样的词语，但他们的具体含义是不一样的，在CAP中是指读取操作最终能够读取到最后一次写入的结果，在分布式事务中是指最终事务完成后，数据严格满足业务约束。

一致性由强到弱分别是：

<font color='red'>XA 事务 > TCC > 二阶段消息 > SAGA </font> 


### XA

2PC

它由两个阶段组成：准备阶段和提交阶段。

准备阶段：
协调者向所有参与者发送事务请求，并等待参与者的响应。
参与者接收到事务请求后，执行事务操作并将日志记录到事务日志中，然后向协调者发送回复（“Yes"或"No"）。
如果所有参与者都回复了“Yes”，协调者将发送“Commit”消息，否则将发送“Abort”消息。

提交阶段：
协调者根据参与者的回复决定是提交还是放弃事务。
如果协调者接收到所有参与者的“Commit”回复，则向所有参与者发送“Commit”消息，参与者完成事务提交。
如果协调者接收到任何参与者的“Abort”回复，或者超时等异常情况，则向所有参与者发送“Abort”消息，参与者放弃事务。

优点：
提供了可靠的数据一致性：只有在所有参与者都准备好并确认事务后，才能提交，保证了数据的一致性。
简单易懂：2PC的工作原理相对简单，易于实现和部署。
适用于少数故障情况：只要协调者和大部分参与者正常工作，2PC可以确保事务的一致性。

缺点：
阻塞问题：在第一阶段的准备阶段，协调者会等待所有参与者的响应，如果有参与者崩溃或网络故障，会导致协调者一直等待并阻塞其他事务的进行。
单点故障：协调者是2PC中的单点，一旦协调者发生故障，整个系统将无法正常工作。
同步阻塞：在准备阶段结束前，所有参与者会阻塞等待协调者的指示，这可能会导致系统的性能下降。
脑裂问题：如果只有部分结点执行了commit命令，数据则不一致。


3PC

3PC，三阶段提交协议，是2PC的改进版本，即将事务的提交过程分为CanCommit、PreCommit、do Commit三个阶段来进行处理。

　　阶段1：CanCommit

　　1、协调者向所有参与者发出包含事务内容的CanCommit请求，询问是否可以提交事务，并等待所有参与者答复。
　　2、参与者收到CanCommit请求后，如果认为可以执行事务操作，则反馈YES并进入预备状态，否则反馈NO。

　　阶段2：PreCommit

　　此阶段分两种情况：

　　1、所有参与者均反馈YES，即执行事务预提交。
　　2、任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。

　　事务预提交：（所有参与者均反馈YES时）

　　1、协调者向所有参与者发出PreCommit请求，进入准备阶段。

　　2、参与者收到PreCommit请求后，执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）。

　　3、各参与者向协调者反馈Ack响应或No响应，并等待最终指令。

　　中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）

　　1、协调者向所有参与者发出abort请求。

　　2、无论收到协调者发出的abort请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。

　　阶段3：do Commit


　　此阶段也存在两种情况：
　　1、所有参与者均反馈Ack响应，即执行真正的事务提交。

　　2、任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。

　　提交事务：（所有参与者均反馈Ack响应时）

　　1、如果协调者处于工作状态，则向所有参与者发出do Commit请求。

　　2、参与者收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源。

　　3、各参与者向协调者反馈Ack完成的消息。

　　4、协调者收到所有参与者反馈的Ack消息后，即完成事务提交。

　　中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）

　　1、如果协调者处于工作状态，向所有参与者发出abort请求。

　　2、参与者使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源。

　　3、各参与者向协调者反馈Ack完成的消息。

　　4、协调者收到所有参与者反馈的Ack消息后，即完成事务中断。

　　注意：进入阶段三后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的do Commit请求或abort请求。此时，参与者都会在等待超时之后，继续执行事务提交。



### TCC



TCC其实有点类似于2PC的准备阶段和提交阶段，但TCC是位于用户代码层面，而不是在基础设施层面，这就为它的实现带来了较高的灵活性，我们可以根据需要设计资源锁定的粒度。


TCC = TRY+CONFIRM+CANCEL 资源冻结+确认+回滚 


本质上隔离性的实现还是依赖于资源冻结后的冲突，优点只操作预留资源性能高，缺点代码侵入强


### SAGA

SAGA必须保证所有子事务都能够提交或者补偿，

SAGA事务通常也不会直接靠裸编码来实现，一般也是在事务中间件的基础上完成。数据补偿来代替回滚，A通过银行B转给C，后续操作异常后因为B作为第三方不具备rollback能力，通过C直接转账给A来实现补偿；

补偿和回滚的区别：回滚指的是事务未提交成功，撤销该事务的所有操作，恢复原始数据状态，补偿则是所有操作全部提交，通过业务手段针对异常数据执行逆向操作；



### AT
我们XA模式有死锁（协议阻塞）问题：XA prepare 后，分支事务进入阻塞阶段，收到 XA commit 或 XA rollback 前必须阻塞等待。如果没有一个靠谱的协调者存在，比如abc三个库的数据被二阶段决议为提交，此时ab收到的指令，提交后，c库在收到指令后挂了，并没有提交xa事务，或者协调者没有做到二阶段重试，那么这个没有提交的xa事务将会一直 持有锁，造成死锁的局面。在这里我们将会引进AT模式，解决同步阻塞等问题。



AT模式前提
> 基于支持本地 ACID 事务的关系型数据库。

> Java 应用，通过 JDBC 访问数据库。



AT模式的原理
数据提交时，自动拦截所有SQL，分别保存SQL对数据修改前后结果的快照，生成行锁，相当于自动记录了重做和回滚日志；

1. 事务的发起者开始一个全局事务，并在本地事务管理器中开始一个本地事务。
2. 事务的发起者调用其他参与者的服务，将全局事务ID传递给它们。
3. 参与者接收到全局事务ID后，在本地事务管理器中开始一个本地事务，并执行操作。
4. 当参与者的本地事务执行成功时，将操作结果记录在本地日志中。
5. 事务的发起者完成所有参与者的服务调用后，调用各个参与者的提交接口。
6. 参与者检查本地事务的日志记录，如果操作都成功，则提交本地事务；否则，回滚本地事务。


跟 2PC 的区别：
AT事务模式并非各自提交各自的事务，而是在一个全局事务的框架下进行协调处理。具体来说，AT事务模式采用了一种优化后的两阶段提交协议，但与经典的两阶段提交（2PC）有所不同。

在AT事务中：

一阶段：业务数据和回滚日志（undo log）被记录在同一个本地事务中并提交，释放本地锁和连接资源。这里的本地事务指的是在单一数据源或单一服务内执行的事务。这个过程中，如果业务数据变更成功，则会生成相应的undo log，用于记录变更前的数据状态，以便在需要时能够进行回滚。

二阶段：提交是异步进行的，非常快速。如果全局事务需要回滚，系统会根据一阶段生成的undo log进行反向补偿，即恢复到事务开始前的状态。

所以，虽然每个本地事务是独立提交的，但它们都是全局事务的一部分，并由全局事务管理器（如Seata中的TC，即事务协调者）来协调。如果在提交后发现全局事务异常（例如，某个参与者事务失败导致全局事务需要回滚），全局事务管理器会触发回滚操作，利用undo log进行反向补偿，确保数据的一致性。

这种方式的优势在于，它避免了2PC中可能出现的长时间等待和阻塞问题，提高了系统的性能和可用性。同时，通过引入undo log机制，确保了即使在异常情况下也能够实现事务的原子性和一致性。

需要注意的是，AT事务模式主要适用于关系型数据库，并且依赖于数据库的ACID特性来保证事务的正确执行。对于非关系型数据库或不支持ACID特性的数据存储系统，可能需要采用其他的事务处理方案。



# 分布式ID


## UUID
UUID（Universally Unique Identifier）是一种标识符，用于在计算机系统中唯一地标识实体。它是一个128位的数字，通常以32个十六进制数字的形式表示，中间用连字符分隔。UUID的生成算法保证了在理论上不同计算机和不同时间生成的UUID都是唯一的。

UUID的唯一性和广泛应用使得它在分布式系统、数据库、网络通信等领域得到广泛使用。它可以用于标识数据库记录、文件、消息、会话等各种实体，确保它们在不同的系统和时间下都能够被唯一标识。

## 雪花算法
雪花ID（Snowflake ID）是一种分布式唯一ID生成算法，由Twitter公司开发。它的设计目标是在分布式系统中生成全局唯一的ID，以解决传统自增ID在分布式环境下可能出现的冲突和性能瓶颈问题。

雪花ID的结构如下：

符号位（1位）：始终为0，表示正数。
时间戳（41位）：记录生成ID的时间戳，精确到毫秒级。
数据中心ID（5位）：用于标识数据中心，最多支持32个数据中心。
机器ID（5位）：用于标识机器，最多支持每个数据中心32台机器。
序列号（12位）：每个节点在同一毫秒内生成的序列号，最多支持每毫秒生成4096个ID。
通过将时间戳、数据中心ID、机器ID和序列号组合在一起，雪花ID可以在分布式系统中生成全局唯一的ID。由于时间戳占据了较高的位数，所以雪花ID生成的ID是递增的，可以保证在一定程度上的有序性。


## MySql自增ID?
MySQL自增ID是一种由MySQL数据库管理系统提供的主键生成机制。它通过自动递增的方式为每条插入的记录生成一个唯一的ID值，用于标识该记录在表中的唯一性。

在MySQL中，自增ID通常与整数类型的列（如INT或BIGINT）结合使用。当插入一条新记录时，MySQL会自动为该列生成一个唯一的ID值，下一次插入时会自动递增。这样可以确保每条记录都有一个唯一的标识符，方便进行数据的查找、更新和删除操作。