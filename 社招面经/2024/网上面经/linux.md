



# select ，poll，epoll
IO 多路复用的区别
* select，poll
select，poll 本质上就是将已连接的socket维护了一个文件描述符集合，通过函数拷贝到内核里，内核遍历文件描述符检查是否有网络时间发生，检查到发生后，将socket修改成可读或者可写，
然后将集合拷贝到用户态，用户态遍历找到可写的socket

select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。

poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。

但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。

* epoll
epoll 将需要检测的文件描述符通过epoll_ctl() 函数加入到内核的红黑树里，
增删改的时间复杂度是O（log n）, 有增加的文件描述符则传入socket即可，减少了内核的和用户空间的大量数据拷贝

epoll采用事件驱动的方式，内核里维护了一个链表来记录就绪事件，当某个socket有事件发生时，通过回调函数加入到事件列表里。

当用户调用epoll_wait()，返回就绪的个数。

边缘触发（ET）: 当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；

水平触发（LT）: 当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，目的是告诉我们有数据需要读取；

举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。

这就是两者的区别，水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。

select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。

