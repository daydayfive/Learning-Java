反射，破坏单例如何预防
1. 使用java的枚举类型来防止反射攻击，Java的枚举类型在反序列化时能够防止创建新的枚举实例，因此使用枚举实现单例模式可以防止通过反射攻击破坏单例状态。


反射消耗性能，Spring 怎么处理的
1. 反射缓存：Spring框架在内部使用了缓存机制来存储反射相关的对象，如Method、Field等，以避免每次使用时都重新进行反射操作。这样，当需要多次访问同一个类的成员时，可以直接从缓存中获取，从而减少了反射的性能
2. Spring在反射调用相关对象时，采用了延迟初始化（lazy init）的策略。这意味着相关对象不会在Spring容器启动时立即初始化，而是在真正需要使用时才进行初始化。这有助于减少启动时的性能开销，并提高系统的响应速度1。
3. 使用JDK动态代理和CGLIB：Spring AOP（面向切面编程）的实现中，使用了JDK动态代理和CGLIB等技术来创建代理对象，而不是直接使用反射。这些技术可以在运行时动态地生成类的子类或接口的实现类，并拦截方法的调用，从而实现切面逻辑。这种方式比直接使用反射更加高效，因为代理对象的创建和方法调用都是经过优化的1。





@Transactional注解
@Transactional 注解不生效的原因可能有多种，以下是一些常见的原因及其解决方法：

注解没有被Spring扫描到：确保你的@Transactional注解被正确地加入到了Spring的组件中（如服务层类），并且这个类被Spring容器管理。

方法不是公开的：@Transactional 只能应用到 public 方法上。如果你的方法不是 public，事务将不会生效。

注解的位置不正确：@Transactional 应该被应用在实际执行数据库操作的服务层方法上，而不是接口或者抽象类中。

事务方法被内部调用所覆盖：如果你在同一个类中调用了一个被@Transactional注解的方法，事务将不会生效，因为Spring的AOP代理不会被应用到同一个类中的方法调用上。

事务管理器配置问题：确保你已经定义了一个有效的事务管理器，并且它被正确地注册到了Spring上下文中。

异常处理问题：默认情况下，@Transactional 只有在运行时异常发生时才会回滚。如果你在事务中抛出了一个检查型异常（Checked Exception），事务不会回滚。你可以通过设置rollbackFor属性来改变这个行为。

注解的propagation属性不正确：如果你的事务方法被错误地配置了传播行为（propagation behavior），可能会导致意外的行为。

Caching issues：确保没有缓存导致Spring无法看到最新的注解配置。

解决方法：

确保Spring能够扫描到@Transactional注解。

确保使用@Transactional注解的方法是公开的。

将@Transactional注解放置在具体执行数据库操作的方法上。

如果需要内部调用事务方法，可以创建一个目标类并通过该类调用事务方法。

确保定义了有效的事务管理器并且正确配置。

如果需要处理检查型异常，请设置@Transactional注解的rollbackFor属性。

根据需要正确配置propagation属性。

如果使用缓存，请确保有效地刷新或重新加载配置。

总结，要使@Transactional注解生效，你需要确保它被正确使用，并且Spring容器的事务管理配置是正确的。




一个类方法调用方法，切面不会生效

一个类里面，方法调用方法导致切面失效的原因主要有以下几点：

Spring AOP的代理机制：Spring AOP默认是基于接口的代理，它使用JDK的动态代理技术。如果类中的方法直接调用另一个方法，这个调用并不会经过Spring的代理对象，因此切面（Aspect）中的通知（Advice）不会被触发。

AOP切面类定义问题：如果在切面类内部定义了切点，并且切面类的方法触发了这个切点，这会导致递归调用，从而可能使切面失效。为了避免这种情况，切面类内部的方法不应该触发切点1。

被代理对象的内部方法调用：当一个被Spring AOP增强的类（即代理对象）的内部方法调用另一个方法时，被调用的方法上的增强通知将不会生效。这是因为Spring AOP的代理机制仅对代理对象的外部调用生效，而内部方法调用不会经过代理对象1。

为了解决这类问题，你可以采取以下几种方法：

使用Autowired注入自身实例：尽管这种方式看起来有些奇怪，但Spring可以解决循环依赖问题，从而避免死循环。通过注入自身的实例，你可以确保调用是通过代理对象进行的。
从Spring上下文获取增强后的实例引用：这与上述方法原理类似，都是从Spring容器中获取代理对象来确保切面生效3。
利用AopContext：在主类入口上设置exporseProxy=true，这样可以在需要的时候获取到代理对象的引用。




@Transactional原理

事务开始时，通过AOP机制，生成一个代理connection对象，
并将其放入 DataSource 实例的某个与 DataSourceTransactionManager 相关的某处容器中。
在接下来的整个事务中，客户代码都应该使用该 connection 连接数据库，
执行所有数据库命令。
[不使用该 connection 连接数据库执行的数据库命令，在本事务回滚的时候得不到回滚]
（物理连接 connection 逻辑上新建一个会话session；
DataSource 与 TransactionManager 配置相同的数据源）

事务结束时，回滚在第1步骤中得到的代理 connection 对象上执行的数据库命令，
然后关闭该代理 connection 对象。
（事务结束后，回滚操作不会对已执行完毕的SQL操作命令起作用）
