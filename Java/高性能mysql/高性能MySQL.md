# 高性能MySQL

## MySQL技术栈

![img](https://cdn.nlark.com/yuque/0/2020/png/1266758/1590590509208-c55e311d-4d15-4bd8-8b43-5bec5a1c2193.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_THVrYQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

## 一. MySQL架构

与其它数据库相比，MySQL的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，**插件式的存储引擎架构**将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务

![img](https://cdn.nlark.com/yuque/0/2020/png/1266758/1590590539775-66b802ba-2c1c-4c50-9cd0-a41eb54578e5.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_THVrYQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

* **连接层**：最上层的服务是一些客户端和连接服务。主要完成一些类似于**连接处理、授权认证、安全**等等。
* **服务层**：第二层服务层，主要完成大部分的核心服务内容，包括查询解析、分析、优化、缓存以及所有的内置函数。所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
* **引擎层**：存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取
* **存储层**：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互。

### MySQL的查询流程

（所有SQL语句都可以称为查询，包括INSERT,DELETE,UPDATE)

--->客户端请求

--->连接器（验证用户身份，给予权限）

--->查询缓存（存在缓存则直接返回，不存在则执行后续操作）

--->分析器（对SQL进行词法分析和语法分析操作）

--->优化器（主要对执行的sql优化选择最优的执行方案方法）

--->执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）

--->去引擎层获取数据返回（如果开其查询缓存则会缓存查询结果）

### MySQL的并发控制

**表锁**：锁定整张表，一个用户对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这回阻塞其他用户对该表的所有读写操作，只有没有写锁时，其他用户才能获得读锁，读锁之间不互相堵塞

**行级锁**：最大程度地支持并发处理（带来了最大的锁开销）



### 事务

* 事务的基本要素（ACID）

* A（atomicity）原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过。
* C（consistency）一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。AID是手段。C是目的。保证数据库在执行前后都处于正确的状态
* I(Isolation)隔离性：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他的并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
* D（Durability）持久性：在事务完成后，该事务所对数据库所做的更改便持久的保存在数据库之中，并不会被回滚。

**（隔离性不够时）****并发事务处理带来的问题**

- **更新丢失（Lost Update)**：事务A和事务B选择同一行，并基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题
- **脏读(Dirty Reads)**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
- **不可重复读（Non-Repeatable Reads)**：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
- **幻读（Phantom Reads)**：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**幻读和不可重复读的区别：**

- **不可重复读的重点是修改**：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）
- **幻读的重点在于新增或者删除**：在同一事务中，同样的条件,第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）



**并发事务处理带来的问题的解决办法：**

- “更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。
- **“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题**，必须由数据库提供一定的事务隔离机制来解决：

- - 一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。
  - 另一种是数据多版本并发控制（MultiVersion Concurrency Control，**MVCC** ）：可以认为是行级锁的变种， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。下面会详细介绍MVCC。

#### 事务隔离级别

隔离级别由低到高：

* READ UNCOMMITTED(未提交读)：事务中的修改，未提交其他事务也是可见。可能会导致**脏读，幻读或不可重复读**
* READ COMMITTED(提交读)：允许读取并发事务已经提交的数据。可以**阻止脏读，但是幻读或不可重复读依旧存在**

* **REPEATABLE-READ(可重复读)**：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止**脏读和不可重复读**，但幻读仍有可能发生。
* **SERIALIZABLE(可串行化)**：最高的隔离级别，完全服从ACID。所有事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止**脏读，不可重复读或幻读。**

查看当前数据库的事务隔离级别：

```mysql
show variables like 'tx_isolation'
```



**事务隔离级别和数据访问的并发性是对立的**，事务隔离级别越高并发性越差。

InnoDB存储引擎在 **REPEATABLE-READ**（可重读）事务隔离级别下使用的是**Next-Key Lock** 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 **SERIALIZABLE**(可串行化)隔离级别，而且保留了比较好的并发性能。

### `NVCC多版本并发控制`

MySQL的大多数**事务型存储引擎实现都不是简单的行级锁**。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同



* MVCC 的实现是通过保存数据在某个时间点的**快照**来实现的。也就是说不管事务需要执行多长时间，每个事物看到的数据都是一致的。根据事务开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的



不同存储引擎的MVCC实现是不同的，典型的有**乐观**并发控制和**悲观**并发控制。

**InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实**现，一个保存了行的创建时间，一个保存行的过期时间。存储的是系统版本号（system version number）。每开始一个新的事务，版本号就会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。



**REPEATABLE READ（可重读）隔离级别下MVCC如何工作：**

- **SELECT：**

- - InnoDB会根据以下两个条件检查每行记录，只有符合上述两个条件的才会被查询出来

- - - 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的
    - 行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除

- **INSERT：**InnoDB为新插入的每一行保存当前系统版本号作为行版本号
- **DELETE：**InnoDB为删除的每一行保存当前系统版本号作为行删除标识
- **UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识**

保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。

MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。



### InnoDB事务日志

**InnoDB 使用日志来减少提交事务时的开销：因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中**。

**事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 I/O**。

随机I/O比顺序IO昂贵得多，因为一个I/O请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。

**InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务**。

InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。

事务日志可以帮助提高事务效率：

- 使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。
- 事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，所以采用事务日志的方式相对来说要快得多。
- 事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。
- 如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。

目前来说，大多数存储引擎都是这样实现的，我们通常称之为**预写式日志**（Write-Ahead Logging），修改数据需要写两次磁盘。





### 事务的实现

​		事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL中支持事务的存储引擎有**InnoDB**和**NDB**。

​		<font color='red'>事务的隔离性是通过锁实现，而事务的一致性和持久性是通过事务日志来实现</font>。

​		事务日志包括：重做日志redo 和回滚日志 undo

* redo log  ：实现持久化

  * redo log 是事务中操作任何数据，都会将最新的数据备份到一个地方

  * 在 InnoDB的存储引擎中，事务日志通过重做（redo）日志和InnoDB存储引擎的日志缓冲（InnoDB Log Buffer）实现。事务开启时， 事务中的操作，<font color='red'>在执行过程中都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化</font>。

  * 在系统启动的时候，就已经为redo log 分配了一块连续的存储空间，以顺序追加的方式redo log，通过顺序IO来改善性能。 所有的事务共享redo log 的存储空间，它们的redo log 按语句的执行顺序，依次交替的记录在一起。

    ![image.png](https://cdn.nlark.com/yuque/0/2020/png/1266758/1596528160059-8e4787a5-7932-43b1-9c53-c01696d8b624.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_THVrYQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

* <font color='red'>undo log（</font>回滚日志）：原子性（要么成功要么回滚）
* undo log是事务开始之前，操作任何数据之前，首先将需要操作的数据备份到一块地方
* undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他事务做的操作
* undo log记录的是已部分完成并且写入磁盘的未完成的事务，默认情况下回滚日志是记录下表空间的
* undo log 和MVCC：
  * undo log中的数据可以作为数据旧版本快照供其他并发事务进行快照都
  * 当读取被其他事务锁定的行时，可以从undo log中分析出该行记录之前的数据是什么，从而实现非锁定一致性读。
* 上面两种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同



上面两种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本

* redo是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录，binlog也是逻辑日志。



### 事务的写入过程

* 一个事务的例子
  * 步骤1：begin
  * 步骤2：insert into t1...r
  * 步骤3：insert into t2...
  * 步骤4：commit

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1266758/1596524923163-af6a94ee-4b8d-4b02-b774-ef99c71f84a9.png)



