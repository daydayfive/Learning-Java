### 三、 MySQL锁机制

## **锁的分类**

* 从对**数据操作**的类型分类：
  * 读锁（共享锁）： 针对同一份数据，多个读操作可以同时进行，不会互相影响
  * 写锁（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁
* 从对数据操作的**粒度**分类：
  * **表级锁**：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率搞，并发度最低（MyISAM和MEMORY存储引擎采用的是表级锁）
  * **行级锁**：开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB存储引擎既支持行级锁也支持表级锁，默认采用行级锁）
  * **页面锁**：介于表锁和行锁之间
* 从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。



## 加锁机制

* 乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题
  * 乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、**处理数据过程中不加锁**，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式
  * 悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、**处理数据前就加排他锁**，**在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁**。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。



## 锁模式

* **记录锁（Record Locks ，也被称为行锁）**：

  * 单个行记录上的锁。对索引项加锁，锁定符合条件的索引而不是真正的数据记录，如果表上没有索引，则会使用自动创建的隐藏主键索引

  * 加上记录锁后，其他事务不能再获取排他锁，即不能修改和删除加锁项（可以快照读）

  * 记录锁分为共享锁和排他锁：

    * 使用共享锁：`SELECT ... `**`LOCK IN SHARE MODE`**

    * 使用排他锁：`SELECT ... `**`FOR UPDATE`**
    * 使用了排他锁，如果事务结束前，其他事务不能修改锁定的数据

  * 使用记录锁的方法：

    * <font color='red'>精确确定哪些行需要加锁时会使用记录锁</font>

    * ```sql
      SELECT * FROM table WHERE id = 1 FOR UPDATE;
      ```

      它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行

* **间隙锁（Gap Locks）**（解决幻读）:

  * 当检索数据是范围条件时，**即不能精准确定哪些行数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁**。
  * 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包括索引项本身，。**使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据**

* **间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的****`Next-Key Locking`** **算法**

* 其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行

* 间隙锁失效在  <font color='red'>读提交</font>（RC）  隔离等级上

* 间隙锁是排他锁，只在UPDATE  ,  DELETE  以及特殊的SELECT语句中出现

* 防止出现一次事务的两次当前读，出现幻读的情况



* 临键锁（Next-key Locks）:

  * 临键锁，是**记录锁与间隙锁**的组合，它的封锁范围，既包含索引记录，又包含索引区间。
  * 临键锁的索引必须是**非唯一索引**，如果索引是唯一索引，则临键锁降级为行锁，仅锁住索引本身，而不会锁住范围
  * 通过临键锁可以解决幻读的问题，每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁柱一段**左开右闭区间的数据**。
  * 解决幻读
  * 例子：

  - - - 表table(id PK, age KEY, name)

  ![image.png](https://cdn.nlark.com/yuque/0/2020/png/1266758/1590748148197-bfa179a3-78e2-4f4f-b304-2f01083a34ca.png)

  - - - 该表中 age 列潜在的临键锁有：-∞, 10], (10, 24], (24, 32], (32, 45], (45, +∞]
      - 在`事务 A` 中执行如下命令：

  -- 根据非唯一索引列 UPDATE 某条记录

  UPDATE table SET name = Vladimir WHERE age = 24;

  -- 或根据非唯一索引列 锁住某条记录

  SELECT * FROM table WHERE age = 24 FOR UPDATE;

  - - - 不管执行了上述 SQL 中的哪一句，之后如果在`事务 B` 中执行以下命令，则该命令会被阻塞：

  INSERT INTO table VALUES(100, 26, 'Ezreal');

* **插入意向间隙锁（Insert Intention Gap Lock）**:

  * 对于数据的修改和删除，必须使用强排他锁，而对于数据的插入不需要这么强的锁
  * 如果多个事务希望对同一个索引间隙插入数据，只要插入的不是同一个位置，则可以直接执行，不用等待其他事务结束，即不会阻塞
  * **使用共享锁提高读读并发，使用插入意向间隙锁提高插入并发**
  * 例子：

  - - - 表索引：t(id unique PK, name)，列name不是唯一索引
      - 表中数据：

  - - - - 10, shenjian
        - 20, zhangsan
        - 30, lisi

  - - - 事务A先执行，在10与20两条记录中插入了一行，还未提交：insert into t values(11, xxx);
      - 事务B后执行，也在10与20两条记录中插入了一行：insert into t values(12, ooo);
      - 这时使用插入意向间隙锁，事务B不会被阻塞

* **总结**
  * InnoDB中的  **行锁**  的实现依赖于  **索引**， 一旦某个加锁操作没有使用到索引，那么该锁就会 退化  **表锁**
  * **记录锁**   存在于包括  **主键索引**  在内的唯一索引中， 锁定单条索引记录
  * **间隙锁**   存在于  **非唯一索引**  中，锁定 **开区间** 范围 内的一段间隔，它是基于 **临键锁**   实现的
  * **临键锁** 存在于  **非唯一索引** 中，该类型的每条记录的索引上都存在这种锁，它是 一种特殊 的  **间隙锁** ，锁定一段 左开右闭 的索引区间。



## 读取方式

* 快照读（Snapshot Read）:基于MVCC  和  undo log 实现的，普通的select读，读数据记录的照片版本，不加锁

     

  ```sql
  select * from t where xxxd
  ```

* 当前读（Current Read）： 基于临键锁（记录锁+间隙锁）实现的，特殊的select 读。读数据记录的最新版本，且在读取完成前需要保证数据不被其他事务修改，因此要加锁

```sql
select * from t where xxx for update  --排他锁
select * from t where xxx lock in share mode ---共享锁
update /insert / delete -----排他锁
```



## 死锁

* **死锁产生**：
  * 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环
  * 当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁
  * 锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。
* **检测死锁**：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。
* **死锁恢复**：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。
* **外部锁的死锁检测**：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决
* **死锁影响性能**：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖`innodb_lock_wait_timeout`设置进行事务回滚。



## with(nolock)（SQL Server）

* with(nolock)是表提示（table_hint）中的一种，等同于READUNCOMMITTED，提高并发查询性能的同时可能会导致脏读
* 特点：
  * 允许脏读：不发布共享锁来阻止其他事务修改当前事务读取的数据，其他事务设置的排他锁不会阻碍当前事务读取锁定数据。允许脏读可能产生较多的并发操作，但其代价是读取以后会被其他事务回滚的数据修改。这可能会使您的事务出错，向用户显示从未提交过的数据，或者导致用户两次看到记录（或根本看不到记录）
  * READUNCOMMITTED 和 NOLOCK 提示仅适用于数据锁。
  * 不能为通过插入、更新或删除操作修改过的表指定 READUNCOMMITTED 和 NOLOCK。SQL Server 查询优化器忽略 FROM 子句中应用于 UPDATE 或 DELETE 语句的目标表的 READUNCOMMITTED 和 NOLOCK 提示
* **使用场景：**

- - 是否使用要综合考虑性能情况与业务要求来决定，大体来说一般有下面一些场景可以使用WITH(NOLOCK)

- - - 基础数据表，这些表的数据很少变更
    - 历史数据表，这些表的数据很少变更
    - 业务允许脏读情况出现涉及的表
    - 数据量超大的表，出于性能考虑，而允许脏读



* 如何产生脏读

- - 不使用的正常情况

- - - 会话窗口1，开启事务修改数据但是不提交也不回滚

- - - - `BEGIN TRAN`
      - `UPDATE TEST SET NAME='Timmy' WHERE OBJECT_ID =1;`

- - - 会话窗口2，查询数据，但是被阻塞了（会话2在等待获取共享锁）

- - - - `SELECT * FROM TEST;`

- - 使用的情况

- - - 会话窗口3，可以查询结果

- - - - `SELECT * FROM TEST WITH(NOLOCK)`

- - - 会话窗口1，回滚，出现脏读

