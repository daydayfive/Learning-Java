

# 1. 网易互娱 研发工程师  一面面经



作者：Hello_GY
链接：https://www.nowcoder.com/discuss/706418?type=all&order=time&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack
来源：牛客网

## Mysql主要存储的数据类型

数值类型： tinyint： 1byte
          smallint: 2bytes
          mediumint: 3bytes
          int:4 bytes
          bigint:8bytes
          float:4bytes
          double:8bytes
          demical
日期类型：date：3 bytes   
         time: 3 bytes
         year: 1 bytes
         datetime: 8 bytes
         timestamp: 4 bytes
字符串类型：
        char
        varchar
        定长与变长的区别，CHAR类型占用空间比较大，但是处理速度比VARCHAR快，如果长度变化不大，如身份证号码那种，最好选择CHAR类型。而对于评论字符串，最好选择VARCHAR

 
## 索引怎么应用的

## 索引除了提升效率还有啥优点
第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 

## 索引有啥缺点
第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间
就会更大。
第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 

## Mysql两种搜索引擎

InnoDB
MyISAM
## 两种搜索引擎差别
InnoDB支持事务，MyISAM不支持
InnoDB支持外键，MyISAM不支持
InnoDB主键是聚簇索引，
MyISAM 是非聚簇索引，索引和数据文件分离
InnoDB不保存表的具体行数， 执行select count(*) from table 需要全表扫描。MyISAM 用一个变量保存了整个表的行数，执行上述语句读出该变量即可，速度很快（因为InnoDB的事务特性，在同一时刻不同事务的表的行数是不一样的）
InnoDB 支持表，行级锁，MyISAM 支持表级锁
InnoDB 必须要有主键，没有指定会自己生成一个隐藏列来充当默认之间，而MyISAM 可以没有




## 怎么选择使用哪个

对于绝大多数都是读的场景，可以选MyISAM

对于有读有写，选择InnoDB

## Redis哨兵
哨兵是redis 高可用性解决方案：由一个或多个Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。

## Redis会导致什么问题


## 怎么解决这些问题

## Final修饰变量
不可变

## Final还有啥使用场景
final修饰引用类型，引用不能变
修饰方法，方法不可被重写
修饰类，类不可被继承

## Final static一起使用有啥作用
分别的，就是 静态的final 变量


## Java多线程方式

继承Thread
实现Runnable
实现Callable
线程池

## 进程和线程
操作系统会以进程为单位，分配系统资源（CPU时间片，内存等资源），进程是资源分配的最小单位
线程，有时被称为轻量级进程，是操作系统调度的最小单位。

进程和线程的区别：
1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位
2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线
3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间（包括代码段，数据集，堆等）及一些进程级的资源（如打开文件和信号），某进程内的线程在其他进程不可见；
4. 调度和切换，进程上下文切换（需要切换页目录以使用新的地址空间）比线程上下文切换要慢。

## 线程池


## Java中主要的线程池
（1）FixedThreadPool:队列长度为Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM
（2）SingleThreadPool:队列长度为Integer.MAX_VALUE, 可能会堆积大量的请求，从而导致OOM
（3）CachedTheadPool：允许创建线程数量为Integer.MAX_VALUE,可能会创建大量的线程，从而导致OOM
（4）ScheduledThreadPool：允许创建线程数量为Integer.MAX_VALUE,可能会创建大量的线程，从而导致OOM

## JVM内存结构
程序计数器：
虚拟机栈：
堆：
本地方法栈：
元数据：

## 哪些是线程私有的
程序计数器
虚拟机栈


## 垃圾处理主要在哪个区
堆  方法区
《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）。

元数据区的垃圾回收： 当类元数据区使用量道道MetaSpaceSize的时候，会触发垃圾回收，然后回收掉无用的类加载器和class对象。MetaapceSize 的值设置的过大会延长垃圾回收时间。


## 垃圾回收方法
标记-清除
标记-复制
标记-整理
分代收集

## 怎么判断是垃圾对象

1. 引用计数法
2. 可达性分析
   
## TCP和UDP
可从TCP 的头结构  跟 UDP 的头结构分析一波区别

都带有目标端口跟源端口
tcp有32位序号以及32位确认序列号，可以让数据按序到达
tcp有个标志比特，可以用来建立连接，udp没有，udp是无连接的
tcp有个16位窗口，因此可以用这个窗口进行流量控制
tcp有16位校验和

udp也有数据校验

## 拥塞控制策略
TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

## try、catch、finally，try里面有return
1、不管有木有出现异常，finally块中代码都会执行；
2、当try和catch中有return时，finally仍然会执行；
3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。


## ==和equals区别
没有重写equals方法前，都是一样的，

## socket由哪些部分组成
描述了双方的ip地址以及端口号

## 常见协议对应端口
http:80
https:443
ftp:20,21
ssh:22
dns:53



## UDP怎么让他可靠

udp属于传输层，传输层无法保证数据的可靠传输，只能通过应用层来实现。



已经有开源程序利用UDP实现了可靠的数据传输，分别为：RUDP,RTP,UDT



在应用层实现确认机制，重传机制，窗口确认机制。
* 添加 seq/ack  机制，确保数据发送到对端
* 添加发送和接收缓冲区，主要是用户超时重传
* 添加超时重传机制
  
1. 发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据达到接受端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送段收到了ack包后，删除缓冲区对应的数据。
2. 时间到后，定时检查任务是否需要重传。


