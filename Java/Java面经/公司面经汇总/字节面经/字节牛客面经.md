# 牛客字节面经汇总
[toc]
# MySQL
## mysql 索引八股，redo log 说一说
redo log 重做日志。redo log 中记录了物理层面的数据页，偏移量作了XXX更新。应对的问题是：MySQL异常宕机后，如何将没来得及提交的事物数据重作出来。

## 三大范式
第一范式（1NF):列不可再分
1. 每一列属性都是不可再分的属性值，确保每一列的原子性
2. 两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据
第二范式 (2NF)：每一行可唯一被区分
第二范式（2NF）是在第一范式的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）.
第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常为表加上一个一个列，即主键。


第三范式 (3NF)：属性直接依赖于主键
数据不存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。
![](images/2021-08-06-21-55-59.png)


## mysql索引优化（结合项目从设计表，explain以及join优化详细聊了自己的看法）

## MVCC
MVCC,多版本并发控制。它在数据库中的目的就是为了提高数据库并发性能，是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。
### MVCC的实现原理
MVCC的实现原理主要是依赖记录中的3个隐式字段，undo log，Read View来实现的。

#### 隐式字段
每行记录除了自定义的字段外，还有数据库隐式定义的 DB_TRX_ID, DB_ROLL_PTR,DB_ROW_ID等字段

* DB_TRX_ID:
  6 byte,最近修改（修改/插入）事务ID:记录创建这条记录/最后一次修改该事务的事务ID
* DB_ROLL_PTR:
  7 byte,回滚指针，指向这条记录的上一个版本（存储于rollback segment里）
* DB_ROW_ID:
  6 byte,隐含的自增ID（隐藏主键），如果数据库没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引
![](images/2021-08-07-13-32-06.png)

#### undo日志
undo log 主要分为两种：
* insert undo log
  代表事务在insert新纪录时产生的undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃
* update uodo log
  事务在进行update 或delete时产生的undo log，不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快照读或事务回滚不涉及该日志时，对应的日志才会被purge 线程统一清除。


#### Read View

Read View就是事务进行快照读操作的时候生产的读视图（Read View），在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID（当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大）


#### 整体流程
可重复读是使用多版本并发控制实现的，即 MVCC。在 innodb 中，对每一行记录都会有三个隐藏列(行号，事务 id，回滚指针)。开启事务后第一条增删改语句会生成比事务 id。第一条查询语句会生成 readView(存放当前未提交的事务 id ，且在可重复读隔离级别下会沿用此 readView)，后面再查询会从最新纪录的事务 id 与当前 readView 中比对，如果存在则沿着回滚指针向前寻找，直到对应纪录的事务 id 不在未提交事务 id 中，则返回结果集，此过程保证了可重复读。幻读也是使用 mvcc 解决的，查询时，某条数据事务 id 大于 readview 中的最大事务 id 则其不可见。




## RC, RR 级别下的InnoDB快照读有什么不同？
正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同

* 在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照即Read View，将当前系统活跃的其他事务记录起来，此后在调用快照读的时候

## mysql 说一下隔离级别，分别解决什么问题

# Redis

## redis zset八股，和红黑树比较，为什么用跳表？
## redis 缓存穿透，缓存击穿，缓存雪崩，继续八股
## Redis单线程为什么这么快，然后深挖底层epoll（为什么单个线程监听多个套接字不会阻塞）
## Redis单线程潜在风险点
## Redis的淘汰算法（LRU算法与常规LRU哪里不同）
## Redis持久化（RDB,AOF,混合持久化）
## AOF重写


# Java
## jdk 动态代理，String 要动态代理的时候，用哪个？
## Synchronized 和static 区别
## 多态
## 数组和链表查询某值谁快？
## Hashmap 八股
## Linkedhashmap和hashmap的区别
## ThreadLoacl的原理
## 为什么key使用弱引用可以解决一部分内存泄漏，但是不能完全解决
## 四大引用的区别 这里一直扯到了垃圾回收机制
## 虚引用的具体作用
## 如何解决hash冲突



# Spring
## spring bean 依赖如何解决？ 
## Spring iod 和Aop 两大核心思想
## SpringIOC的优势说一个具体的例子
## Spring AOC的具体使用，是怎么实现的，动态代理具体是怎么实现的

# 设计模式

## 单例模式
## 工厂模式了解嘛？单例做什么的，怎么实现

# IO模型

## IO多路复用，epoll和select区别

# 操作系统
## 线程通信方式
## 进程有哪些状态
## 怎么实现这些状态转换的
## 阻塞和等待状态的区别
## 进程和线程的区别
## 线程的共享的资源
## 用户态和内核态的转变
## 虚拟内存
## 缺页中断，页面置换算法
## 磁盘调度算法

# Linux
## a是b的父进程，如果a挂了b会怎样？
## 僵尸进程和孤儿进程

# 计网
## 浏览器输入一个域名，会发生什么
## 计算机网络各种 从osi七层，https，tcp两次握手会怎样，如何保证不丢包，保证顺序。
## tcp和udp
## tcp怎么保证可靠性传输
## 拥塞控制
## ssl握手
## 客户端怎么验证ca证书，连接后怎么传输数据
## 现在我们进行这样一个视频面试，可能会用到哪些协议，你能想到的都说。
```
DNS、HTTP、HTTPS、TCP
```
## 视频传输你觉得会用到什么协议，为什么？



# JVM
## JVM的垃圾回收机制
## 说下JVM中有哪些内存
## 讲讲GC过程，标记整理算法怎么实现的
## 类加载机制
## 怎么实现同步
## GCroot都有那些呢

## 内存什么时候会出现一个锯齿状的波动
## 为什么垃圾回收次数发生很多会不好。

## 那内存的波形图是很小的锯齿形，很很大的锯齿形那种好
## 那波动很大怎么解决？
## 在一个for循环中每次都需要建立一个很大的对象，这一个对象就快把内存占满了，不想每次都发生GC又不想每次都重新设置该怎么办。缓存的设计

## 