
[toc]
# 阿里java面经

## 1. Java 容器:List,Set,Map
List: 继承Collection的接口，即List 是集合中的一种。List 中是有序的队列，每一个元素都有一个索引。而且List允许有重复的元素。

Set：继承于Colletion接口，set是一种不包含重复元素的Collection，它维持它自己的内部排序。

Map：map是一系列键值对组成的集合，提供了key到value的映射。保证了key 与value一一对应的关系。因此它也不能存在相同的key值。




## 2.Map的遍历方法

1.map.keySet()获取到值，然后根据键获取到值
```java
for(String s:map.keySet()){
    map.get(s);
}
```
2. Map.Entry(String,String)  map.entrySet()

3. Iterator 也是为了获得entry


## 3. HashMap扩容为什么是扩为2倍
为了让hashMap的容量为2的n次幂，因为计算索引的时候是根据 hash&(n-1);
只有当0111111的时候，每个位置都有可能被放入元素，减少hash碰撞

## 4. Java线程同步机制（信号量，闭锁，栅栏）
信号量：Semaphore
闭锁：CountDownLatch
栅栏：CyclicBarrier

CountDownLatch 和CyclicBarrier 都是线程同步的工具类

CountDownLatch 基于AQS实现，会将构造CountDownLatch 的入参传递至state，
执行countDown方法时，其实就是利用CAS将state-1
执行await方法时，就是判断state是否为0，不为0则加入到队列中，将线程阻塞掉
因为头结点会一直自选等待state为0，当state为0时，头结点把剩余的在队列中阻塞的节点也一并唤醒。

CyclicBarrier 上，它是借助ReentrantLock 加上Condition等待唤醒的功能进而实现的

在构建CyclicBarrier时，传入的值会赋值给 count变量，也会赋值给parties变量，每次调用await时，会将count-1，操作count值是直接使用ReentrantLock来保证线程安全性

如果count不为0，则添加至condition队列中，如果count等于0时，则把节点从condition队列添加至AQS的队列中进行全部唤醒，并且把parties的值重新赋值为count的值，（实现复用），同时调用barrierCommand 


Semaphore通常叫做信号量，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。
Semaphore 实现原理：
（1）Semaphore初始化
```java
Semaphore semaphore=new Semaphore(2);
```
会将输入的值赋值给state状态，state的值就代表当前剩余的令牌数量
（2）获取令牌
```java
semaphore.acquire();
```
1. 线程会通过cas修改state 的值，如果state的值<0,则将线程挂起

（3）释放令牌
```java
semaphore.release();
```
1. 会释放一个令牌，cas将state+1
2. 去唤醒同步队列里的一个线程
3. 被唤醒的节点重新尝试去修改state=state-1 如果state》=0 则获取令牌成功，否则重新进入阻塞队列，挂起线程



## 5. 对volatile

volatile 是java的一个关键字，用它修饰的变量保证了变量的可见性以及禁止指令重排序。
它是一种比synchronized 关键字更轻量级的同步机制。



## 6.八种基本数据类型的大小以及他们的封装类
char：8位  Charcter
byte：8位 Byte
boolean：true or flase Boolean
short：16位 Short
int：32位 Integer
long：64位 Long
float：32位 Float
double：64位 Double
**基本数据类型都存在栈上**

整型，char类型所对应的包装类，在自动装箱时，对于-128 和127之间的值会进行缓存处理

每次装箱的时候，就是调用valueOf(),会判断这个值是不是在上面这个区间，如果在直接获取，不再则创建新对象


## 7 线程阻塞几种情况？如何实现阻塞队列？


## 8 Java垃圾回收


## 9 java 内存模型


## 10 TCP/IP的理解
TCP/IP协议模型，包含了一系列构成互联网基础的网络协议，是Internet的核心协议。

基于TCP/IP的参考模型将协议分为四个层次，他们分别是链路层，网络层，传输层和应用层。

TCP/IP 协议族按照层次从上到下，层层包装，最上层是应用层，这里面有http，ftp等熟悉的协议，第二层是传输层，tcp，udp在这，第三层是网络层，IP协议就在这里，负责对数据加上ip地址和其他数据确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入以太网协议头，并进行crc编码，为最后的数据传输做准备。

而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。

## 11 进程和线程的区别

进程是计算机已运行程序的实体，进程是操作系统资源分配的最小单位，每一个进程都有它自己的内存空间和系统资源

线程是进程中执行的一个任务，是CPU调度和执行的最小单位。

它们两个本质的区别是 是否单独占有内存地址空间及其它系统资源（比如I/O）：

区别如下：
进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。

进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高;一个线程崩溃可能影响整个程序的稳定性，可靠性较低。

进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。


## 12 http状态码含义
成功2xx:成功处理了请求的状态码。
200：服务器已成功处理了请求并提供了请求的网页。
204：服务器成功处理了请求，但没有返回任何内容。


重定向3xx:
301： 请求的网页已永久移动到新位置。当URLs发生变化时，使用301代码。搜索引擎索引中保存新的URL。

302： 请求的网页临时移动到新位置。搜索引擎索引中保存原来的URL。

304： 如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器人，可节省带宽和开销。

4xx:表示请求可能出错，妨碍了服务器的处理
400： 服务器不理解请求的语法
403：服务器拒绝请求
404：服务器找不到请求的网页

5xx:表示服务器在处理请求发生内部错误。
500：服务器错误
503：服务器目前无法使用

## 13 ThreadLocal，如何实现一个本地缓存


## 14 JVM内存区哪里会出现溢出?
线程共享：堆，方法区在jdk1.8之后被转移到堆外内存，由元数据区替换掉永久代


线程私有：栈，本地方法栈，程序计数器



## 15 双亲委派模型的理解，怎样将两个全路径相同的类加载到内存中？

Java判断两个类是否相同除了判断类本身，还需要判断类加载器是否相同，因此使用不同的类加载器进行加载就OK了
## 16 CMS 收集器和G1收集器


## 17 TCP流量控制和拥塞控制
流量控制：
tcp用一个滑动窗口用于进行流量控制，通过TCP报文中的窗口大小win字段实现的，


## 18 服务器处理一个http请求的过程
1.浏览器拿到url时，首先会对url进行解析，使用DNS协议，通过域名得到IP地址。
（PS：浏览器会查询缓存，如果有这个网址的缓存则可以直接获取到ip，如果没有查询本机缓存，如果没有则进行DNS请求）。

2.得到ip后浏览器与服务器通过TCP三次握手建立连接。

3.浏览器构建HTTP请求报文，并通过TCP协议传送到服务器的指定端口。http请求报文一共包括三个部分：

请求行：指定http请求的方法，url，http协议版本等
请求头：描述浏览器的相关信息，语言，编码等。
请求正文：当发送POST,PUT等请求时，通常需要向服务器传递数据。这些数据就储存在请求正文中。
4.服务器处理HTTP请求，并回复响应报文。响应报文分为三个部分：

状态码：http服务常用的状态码及其含义如下
响应头：包含了响应的相关信息，如日期等
响应正文：服务器返回给浏览器的文本信息
5.浏览器页面渲染

6.断开tcp连接
四次挥手

## 19 列举几个Mysql优化手段
1.对查询进行优化，避免全表扫描加索引
2.尽量不给数据库留nul值，避免引擎放弃使用索引而进行全表扫描
3.对于连续的数值，能用 between 就不要用 in 了：

## 20 数据库死锁定义，怎样避免死锁
当多个进程同时访问一个数据库，其中的每个进程拥有的资源都是其他进程所需的，由此造成的每个进程都无法继续下去的情况。


死锁产生四个条件：
1. 互斥：一个资源只允许一个进程使用
2. 请求与保持：当进程至少拥有一个资源，但又提出了新的请求，这时候进程阻塞，但不会释放他自己拥有的资源
3. 不可剥夺： 进程已获有的资源，在未使用完前，不能被剥夺
4. 循环等待： 存在一个链


如何避免死锁：
a. 保持事务简短并在一个批处理中
b. 使用低级别的隔离（比如读未提交，就不需要等待其他事务提交）
c. 按同一顺序访问对象


## 21 spring的aop是什么？如何实现的

## 22 面向对象的涉及原则

## 23 策略模式的实现
策略模式在面对存在一系列 if  else 判断的情况下，
例如打折这一情况，如果后面可能存在新的折扣，就需要修改代码，不符合开闭原则。

就可以让策略继承一个抽象类，自己实现，然后用一个环境类去引用策略了，来实现它。

适用场景：
* 一个系统需要动态地在几种算法选择一种，那么可以将这些算法封装到一个个具体算法中，而这些具体算法类都是一个抽象类的子类。换言之，这些具体算法类均有统一的接口，根据“里氏替换原则”和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象。


## 24 操作系统的内存管理的页面淘汰算法，相较下LRU



## 25 B+树的特点与优势