[toc]


#1.

## Java 里的Map 里优秀的设计
HashMap 的数据结构 底层使用了数组+链表+红黑树数据结构，红黑树是为了防止链表过长后，遍历所需时间太长

hashmap每次扩容都为2的倍数，是为了让每个位置都可以放入数据，减少hash碰撞的改率

计算hash的时候将高16位参与hash运算，是为了能够更好的均匀散列，减少碰撞



## Semaphore， CountDownLatch，CyclicBarrier 区别

Semaphore 是信号量，用来做多个资源的同步 acquire获取资源，如果资源满了等释放 , release

## 说说Mysql 的 bin log，redo log 和 undo log（说了怎么实现的，作用）
redo log 是innodb引擎自带的日志功能，又叫重做日志，主要用于数据库崩溃后将没有刷盘的数据的重放，redo log 是循环写的

undo log 一般记录与操作完全相反的操作，可用于快照读以及事务的回退。

bin log是Server 层自带的日志，归档日志，主从复制搭建，bin log是追加写，逻辑日志，记录了更新语句的逻辑操作


## 说说 Mysql 的索引（说了InnoDB 的 聚簇索引和非聚簇索引，MyISAM 的二级索引，hash 索引）

InnoDB主键就是聚簇索引
聚簇索引：聚簇索引叶子节点数据，
非聚簇索引：叶子节点指向主键。

MyISAM 主键和二级索引都是非聚簇索引，但是它们的叶子节点保存的是数据的物理地址。



## Redis 为什么不需要多线程（Redis 性能瓶颈在于内存和网络IO，使用了多路复用）


## Redis 多路复用怎么实现（Reactor 模式）
redis I/O多路复用模型使用了Reactor设计模式实现了这一机制。通过一个线程监听多个连接，当发生文件时间产生时，就会调用事件对应的handler。同时I/O多路复用，同时了多个FD的监控，提高了网络通信的性能。


封装了底层的select，poll，epoll



##　select，poll，epoll 的区别，水平触发和边缘触发的区别
select 有三个问题：1.每次调用的时候，都需要把fd集合从用户态拷贝到内核态，这个开销在FD很多时会很大。
2. 每次都需要在内核遍历fd集合
3. 支持的文件描述符为1024个

poll解决了第三个问题，select用一个数组（bitmap）32个32位数，，poll改成了链表，突破了fd的个数现置。

epoll解决了前两个问题，
（1）epoll 每次注册新的事件到epoll句柄中，会把所有的fd拷贝进内核，而不是epoll_wait的时候拷贝，这样就不会出现重复拷贝
（2）epoll单独设置了一个就绪链表，当fd就绪后，就放入就绪链表，只需要遍历就绪列表即可，不需要遍历fd列表。


水平触发：只要fd处于可读或可写，就会通知用户；

边缘触发：当不可读变为可读，不可写变为可写之时，才会通知用户。

ET对系统的调用，比LT要少得多，所以ET是高速工作模式
因此用户在使用边缘触发的时候，就需要连续读完或者写完，否则系统会认为状态没有变化，就不会重复通知。


　
## Redis 过期键删除策略（惰性删除 和 定期删除），常用类型（string，list，hash，set，zset），sds 怎么实现的，这样实现的优点（可动态扩展内存、二进制安全、快速遍历字符串 和与传统的C语言字符串类型兼容）



## GET 和 POST 区别（幂等性，参数位置和长度，是否可缓存，安全性）

get 把请求放在url中，post通过请求体来传递参数


get产生一个tcp数据包

post产生两个数据包。
post先发送header，浏览器响应100continue，浏览器在发送data，服务器响应200 ok

2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

## HTTP 3.0 的优势（说了是基于UDP实现的），然后问为什么基于UDP（没答出来），主流在用的HTTP协议（HTTP 1.1，不知道是不是），HTTP 2.0 的优点（只答出来了 首部压缩）

HTTP1.1在应用层以纯文本的形式进行通信，每次通信都需要带上完整的HTTP的头，而且不需要考虑pipeline模式的话，每次的过程都需要一去一回。

而为了解决这些问题，HTTP2.0 对HTTP进行首部压缩，将每次要携带的大量key value在两端简历一个索引表，对相同的头只需要发送k索引。
同时，HTTP2.0 协议将一个TCP的连接中，切分为多个流，每个流都有自己的ID。将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输，这些帧可以打散乱序发送，然后根据每个帧的首部重新组装。

HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题（服务器端响应需要按照客户端请求的顺序来响应），同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应；减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。


然而HTTP2.0还是用了tcp连接，tcp在处理包的始有严格顺序的，因此仍然存在队首阻塞的问题。
HTTP2.0 自定义了连接和重传机制，然后采用udp。不需要等待重传的包
QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。

## SpringBoot 相比 Spring 的优点（自动配置，不用写一堆xml配置文件）


# 2. 

## 1. Java的三大特性。
 1.封装
 2.继承
 3.多态

## final关键字的作用
修饰基础类型  不能被修改
修饰引用类型 引用不能被改
修饰类 不可被继承
修饰方式  不可被重写

## 抽象类和接口
接口的设计目的，是对类的行为进行约束（约束了行为的有无）
抽象类的设计目的，是代码复用。 当不同的类有某些相同的行为的时候，其中一部分的实现方式一致时，可以让这些类派生于一个抽象类，抽象类中实现了B，避免所有的子类来实现它。

相同点：
（1）都不能实例化
（2）接口的实现类或抽象类的子类都只有实现了接口或抽象类的方法后才能实例化

不同点：
（1）接口只有定义，不能有方法的实现，而抽象类可以有定义和实现
（2）实现接口的关键字为implements，继承抽象类的而关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
（3）接口强调特定功能的实现，而抽象类强调所属关系
（4）接口成员变量默认为public static final，必须赋初值，不能被修改

## 类的加载机制
当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载

类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。


类加载机制主要有三种：

* 全盘负责：当一个类加载器负责加载某个class时，该class所依赖和引用的其他class也由该加载器加载
* 双亲委派：
* 缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为什么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。


## 相同类会被重复加载
会被不同的类加载器加载

## hashmap是线程安全的嘛。要线程安全的怎么办
不是
concurentHashmap

## 创建线程的方式
继承thread
实现runnable
实现callable
线程池

## 线程池是怎么管理线程的


## redis作为中间缓存层如何描述数据一致性
1. 对于读写缓存来说，可以通过事务来保证 修改缓存以及数据库的 一致性
2. 只读缓存来说，由于存在删除缓存与修改数据库，
   如果当这两个操作出现了更新失败，则采用重试机制，重试直到成功为止。

3. 而先删除缓存以及更新数据库时，如果存在第二个线程在更新数据库的时候获取数据，可能会将旧值放到缓存，因此需要延迟双删

4. 而先更新数据库后删除缓存，这时候中间请求的时候获取的数据依旧是旧值。