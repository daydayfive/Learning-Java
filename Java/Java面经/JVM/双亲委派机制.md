[toc]
# 双亲委派机制


## 什么是双亲委派机制？

**所谓的双亲委派机制**：当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的**父加载器**去加载。只有父加载器**无法加载**这个类的时候，才会由当前这个加载器来负责类的加载。

其实，Java中提供的这四种类型的加载器，是有各自的职责的：

Bootstrap ClassLoader ，主要负责加载Java核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等。
Extention ClassLoader，主要负责加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。
Application ClassLoader ，主要负责加载当前应用的classpath下的所有类
User ClassLoader ， 用户自定义的类加载器,可加载指定路径的class文件



## 为什么需要双亲委派机制，不委派有什么问题？
因为类加载器之间有严格的层次关系，那么也就使得Java也随之具备了层次关系。

比如说一个定义在java.lang包下的类，因为它被存放在rt.jar之中，所以在被加载过程汇总，会被一只委派到Bootstrap ClassLoader，最终由Bootstrap ClassLoader 所加载。

而一个用户自定义的com.hollis.ClassHolli类，也会被委派到Bootstrap ClassLoader，但是因为它不负责加载该类，最后自顶向下到Application ClassLoaderj加载。

这种机制有几个好处？
首先，**通过委派的方式，可以避免类的重复加载**，当父加载器已经加载过某一个类时，子加载器就不会重新加载这个类

通过**委派的方式，还保证了安全性**。因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Integer，那么这个类是不会被随意替换的，除非有人跑到你的机器上， 破坏你的JDK。



## “父加载器”和“子加载器”之间的关系是继承的吗？
不是。
双亲委派模型中，类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合的关系来复用父加载器的代码的。
如下为ClassLoader中父加载器的定义：
```java
public abstract class ClassLoader {

        // The parent class loader for delegation

        private final ClassLoader parent;

    }
```


## 双亲委派是怎么实现的？

双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现并不复杂。

实现双亲委派的代码都集中在**java.lang.ClassLoader的loadClass()**方法之中：

代码不难理解，主要就是以下几个步骤：

1、先检查类是否已经被加载过

2、若没有加载则调用父加载器的loadClass()方法进行加载

3、若父加载器为空则默认使用启动类加载器作为父加载器。

4、如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。


## 能不能主动破坏这种双亲委派机制，如何破坏？

因为双亲委派机制主要是在loadClass方法实现的，那么想要破坏这种机制，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可。


## 为什么重写loadClass方法可以破坏双亲委派，这个方法和findClass()、defineClass（）区别是什么？
* loadClass()就是主要进行类加载的方法，默认的双亲委派机制就在实现这个方法。
* findClass()根据名称或位置加载.class字节码
* defineclass()把字节码转化为Class

JDK1.2之后已不再提倡用户直接覆盖loadClass()方法，而是建议把自己的类加载逻辑实现到findClass()方法中。

因为在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载。

所以，如果你想定义一个自己的类加载器，并且要遵守双亲委派模型，**那么可以继承ClassLoader，并且在findClass中实现你自己的加载逻辑即可。**


## 说一说所知道的双亲委派被破坏的例子
第一种被破坏的情况是在双亲委派出现之前。

第二种，是JNDI、JDBC等需要加载SPI接口实现类的情况。

第三种是为了实现热插拔热部署工具。为了让代码动态生效而无需重启，实现方式时把模块连同类加载器一起换掉就实现了代码的热替换。

第四种时tomcat等web容器的出现。

第五种时OSGI、Jigsaw等模块化技术的应用。

## 为什么JNDI，JDBC等需要破坏双亲委派机制

如典型的JDBC服务，通常通过以下方式创建数据库连接：
```java
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mysql", "root", "1234");
```
在以上代码执行之前，DriverManager会先被类加载器加载，因为java.sql.DriverManager类是位于rt.jar下面的 ，所以他会被根加载器加载。

但是类加载时，会执行该类的静态方法，其中有一段关键的代码是：
```java
ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
```
**DriverManager是被根加载器加载的，那么在加载时遇到以上代码，会尝试加载所有Driver的实现类，但是这些实现类基本都是第三方提供的，根据双亲委派原则，第三方的类不能被根加载器加载。**

那么，如何解决这个问题呢？

在JDBC中通过引入**ThreadContextClassLoader**（线程上下文加载器，默认情况下是AppClassLoader）的方式破坏了双亲委派原则。

获取当前线程的线程上下⽂类加载器 AppClassLoader，⽤于加载 classpath 中的具体实现类。


## 为什么Tomcat要破坏双亲委派机制
我们知道，Tomcat是web容器，那么一个web容器可能需要**部署多个应用程序**。

不同的应用程序可能会依赖**同一个第三方类库的不同版本**，但是不同版本的类库中某一个类的全路径名可能是一样的。

如多个应用都要依赖hollis.jar，但是A应用需要依赖1.0.0版本，但是B应用需要依赖1.0.1版本。这两个版本中都有一个类是com.hollis.Test.class。

如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类。

所以，Tomcat破坏双亲委派原则，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。

Tomcat的类加载机制：为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派的约定，每一个应用自己的类加载器——WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。

## 谈一谈对模块化技术的理解




参考文章：
https://zhuanlan.zhihu.com/p/343563937

