[TOC]

#悲观锁和乐观锁是什么？


##悲观锁（多写场景）
悲观锁正如其名，比较悲观。总会认为：每当修改数据时，会有其他线程也会同步修改该数据。所以针对这种情况悲观锁的做法是：读取数据之后就加锁，这样别的线程读取该数据的时候就需要等待当前线程释放锁，从而保证了并发修改数据的错误的问题。

Java中的同步锁**synchronized**和**ReentrantLock** 就是**悲观锁**思想的实现。


##乐观锁（多读场景）

乐观锁就是 只有在**更新数据的时候才会检查这条数据是否被其他线程更新了**。如果更新数据时，发现这条数据被其他线程更新了，则此次更新失败。如果数据未被其他线程更新，则更新成功。 由于**乐观锁没有了锁等待，提高了吞吐量，所以乐观锁适合多读少写的场景。**

Java中的atomic原子变量就是乐观锁的实现。


# 总结

悲观锁：读取时加锁，更新完释放锁，在此过程中会造成其他线程阻塞，导致吞吐量低，是用于多写场景。

乐观锁：不加锁，只有在更新时验证数据是否被其他线程更新，吞吐量较高，适用于多读场景。

