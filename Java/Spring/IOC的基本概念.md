# IOC的基本概念

**IOC**（Inversion of Control）:让别人为你服务

![image-20201127163740399](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201127163740399.png)

* 被注入对象如何通过哪些方式来通知IoC Service Provider 为其提供适当服务（三种依赖注入的方式）

  * **构造方法注入**（constructor injection）

    被注入对象在其**构造方法中声明依赖对象的参数列表**，让外部（IOC容器）知道哪些依赖对象。

    IoC Service Provider会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注 入相应的对象。同一个对象是不可能被构造两次的，因此，被注入对象的构造乃至其整个生命周期， 应该是由IoC Service Provider来管理的

    **优缺点**：对象在构造完成之后，即已进入就绪状态，可以 马上使用。缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反 射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且 在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多 个构造方法，而参数数量的变动可能造成维护上的不便。 

  * **setter**方法注入

    对于JavaBean对象来说，通常会通过setXXX()和getXXX()方法来访问对应属性。这些setXXX() 方法统称为setter方法，getXXX()当然就称为getter方法。

    **优缺点**：因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。 另外，setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。缺点当然就是对象无 法在构造完成后马上进入就绪状态。 

    当前对象只要为其依赖对象所对应的属性添加setter 方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。

    setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些， 可以在**对象构造完成后再注入**

  * **接口注入**（退役状态）

    被注入对象需要实现一个接口，该接口的**方法  的参数就是所依赖对象的类型**