# JAVA虚拟机

## 1.JAVA内存区域

### JAVA内存结构

![JVM内存结构.jpg](https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1586828131069-3c2041fb-d254-414c-a3ab-5b3673990be1.jpeg)

* 根据线程划分的内存模型

![JVM线程内存结构.jpg](https://cdn.nlark.com/yuque/0/2020/jpeg/1266758/1586828210341-73dfbc31-682b-40bd-9e9b-9f6078789bdb.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_THVrYQ%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

### 程序计数器

* 当前线程执行的字节码的行号指示器
* 通过改变程序计数器的值来选取下一条需要执行的字节码指令， 可让线程切换后能恢复到正确的执行位置
* 唯一一个不会OutOfMemeryError的区域



### 虚拟机栈

* 生命周期与线程相同
* 描述JAVA方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，栈帧在虚拟机栈的入栈到出栈，对应着每一个方法的调用到执行完成（所以递归很有可能导致一直入栈导致错误）
* 栈帧存储：**局部变量表、操作数栈、动态链接、方法出口**
  * **栈内存**指  局部变量表部分（存放了各种基本数据类型，对象引用）
  * 局部变量表的内存空间  在编译期间完成分配（方法运行期间不会改变局部变量表的大小）
* StackOverflowError异常：线程请求的栈深度大于虚拟机允许的深度
* OutOfMemoryError异常：虚拟机栈扩展时无法申请到足够的内存



### 本地方法栈

* 作用与虚拟机栈类似，为虚拟机找到的本地方法服务
* 同样会抛出SOE以及OOE异常



### 堆

* 存放对象实例（所有线程共享）
* 垃圾收集器管理的主要区域
* 可以是物理上不连续的内存空间
* 从内存分配的角度来看，线程共享的 Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,**TLAB**）
* OOE:没有内存完成实例分配，堆也无法扩展时



### 方法区

* 与堆一样，各个线程共享
* 存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据
* JDK1.8前称为永生代(Permanent Generation)，之后属于MetaSpace元空间
* OutOfMemoryError异常：无法满足内存分配需求时抛出
* **运行时常量池**时方法区的一部分，。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于 存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 （无法申请内存时同样会抛出OutOfMemoryError）



### 直接内存

- 不属于JVM内存区域，但频繁使用
- **NIO类(New Input/Output)使用基于Channel与Buffer的I/O方式，可以使用Native函数库直接分配堆外内存，使用堆中的DirectBuffer对象对该内存引用，避免Java堆和Native堆之间来回复制数据**
- OutOfMemoryError异常：内存无法扩展时同样会抛出OOM异常



## 2.JAVA对象

### 对象的创建

* 虚拟机遇到一条**new**指令
* 检查在常量池中定位到一个类的符号引用，并检查该符号引用的类是否被加载、解析和初始化
  * 如果没有，执行相应的类加载
* **分配内存**---》（**两种方案**：内存规整---指针碰撞，内存相互交错-----空闲列表）
  * 方案由堆是否规整决定，堆是否规整由采用的垃圾收集器是否歹有压缩整理功能决定
  * 防止分配内存时并发发生错误
    * CAS+失败重试----》操作的原子性
    * 按照线程划分在不同的空间之中进行（TLAB）
* 对分配的内存初始化为零值（不包括对象头）
* 设置对象头
  * 设置   这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC年代年龄
  * 根据虚拟机当前的运行状态，有不同的设置方法



## 3. 对象的内存布局（对象头，实例数据，对齐填充）

* **对象头**

  * **第一部分信息：对象自身的运行时数据：**

    * HashCode  ,GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等（Mark Word）

    * 上述数据在32位和64位的虚拟机中分别位32bit和64bit

      * 由于存储的数据大多超出了限度，（设计为非固定的数据结构，根据对象状态复用存储空间）

      * 未被锁定的状态下，那么Mark Word的32bit空间中的25bit用 于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0

      * 其他状态

        ![image-20201127154743193](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201127154743193.png)

  * **第二部分信息： 类型指针**  

    * 虚拟机通过这个指针确定对象是哪个类的实例
    * 如果对象是数组，对象头中还会存有数组长度

  

   *   实例数据
   *   对齐填充
          *   仅仅起着占位符的作用，对象起始地址需要时8字节的整数倍，对象头是的，当实例数据没有对齐时，需要对齐填充





## 4.对象的访问定位

* **句柄**
  * 对象被移动时(GC时移动对象)，只需要改变句柄中的实例数据指针，reference本身不用修改。对象类型数据可以认为是.class文件数据

![image-20201127155239343](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201127155239343.png)

* **直接指针**
  * 速度更快，节省一次指针定位的时间开销

![image-20201127155328212](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201127155328212.png)