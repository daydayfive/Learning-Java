# 运行期优化

## 编译器与解释器

* 程序需要迅速启动和执行的时候，解释器首先发挥作用，省去编译的时间，立即执行。随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获得更高的执行效率。

* 程序运行环境中内存资源限制较大时，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。

* 同时，解释器还可以作为编译器激进优化时的一个“逃生门”，当激进优化的假设不成立时，可以通过“逆优化”退回到解释状态继续执行。

  ## 编译对象与触发条件

  * 热点代码：当虚拟机发现某个**方法**或某个**循环体**运行特别频繁时，会将这些代码认定为“热点代码”，
  * 即时编译器（Just in Compiler,JIT):将热点代码编译成与本地平台相关的机器码，并进行各种层次的优化
  * 热点探测（判断一段代码是不是热点代码）：
  * 基于采样的热点探测：周期性的检查各个县城的栈顶，如果发现某个方法经常出现则认为是热点方法
  * 基于计数器的热点探测：为每个方法（甚至是代码块）建立计数器，执行次数超过阈值则认为是热点方法，实现麻烦一点但是严谨。

## 优化技术举例

* 代码优化变换是建立在代码的某种中间表示或机器码之上，这里用Java语言展示

* 优化前的原始代码

  ```java
  static class B{
      int value;
      final int get(){
  		return value;
      }
  }
  public void foo(){
  	y=b.get();
      //...do stuff...
      z=b.get();
      sum=y+z;
  }
  ```

  - 方法内联(Method Inlining)——最重要的优化措施

  - - 主要目的：
    - 去除方法调用的成本(如建立栈帧等)
    - 为其他优化建立良好的基础

```java
//方法内联后的代码展示
public void foo(){
	y=b.value;
    //...do stuff...
    z=b.value;
    sum=y+z;
}
```

* 冗余访问消除

- - 假设代码中间注释的do stuff的操作如果不会改变b.value的值，那就可以把z=b.value替换为z=y，这样就可以不再去访问对象b的局部变量

```java
//冗余访问消除的代码展示
public void foo(){
	y=b.value;
    //...do stuff...
    z=y;
    sum=y+z;
}
```

- 复写传播

- - 这段程序的逻辑中并没有必要使用额外的变量z，可以使用y来代替z

```java
//复写传播的代码展示
public void foo(){
	y=b.value;
    //...do stuff...
    y=y;
    sum=y+y;
}
```

- 无用代码消除

- - 永远不会执行的代码或完全没有意义的代码称为无用代码

```java
//无用代码消除的代码展示
public void foo(){
	y=b.value;
    //...do stuff...
    sum=y+y;
}
```





语言无关的经典优化技术之一：公共子表达式消除。 

语言相关的经典优化技术之一：数组范围检查消除。 

最重要的优化技术之一：方法内联。

 最前沿的优化技术之一：逃逸分析。 





## 代表性的优化技术

* **公共子表达式消除**
* 如果一个表达式E已经计算过了，并且之前计算的结果到现在所有变量的值都没有改变，那么E的这次出现就成为了公共子表达式，没有必要再进行计算，直接用前面的结果代替E即可

```
int d=(c*d)*12+a+(a+b*c)` →`int d=(E)*12+a+(a+E)
```

当然还可以使用代数化简，优化成→`int d=E*13+a*2`





* **数组边界检查消除**
* 访问数组时系统自动进行上下界的范围检查，每次读写都会有一次隐含的条件判定操作，无疑是性能负担
* 编译器通过数据流分析，判定循环中的循环变量的取值范围永远不会越界，那么就在整个循环中把数组的上下界检查消除



* **隐式异常处理**（各种异常判断）
* Java中空指针检查和算术运算中除数为零的检查都采用了这种思路
  * 如果foo不为空时不会额外消耗一次对foo判空的开销
  * 但是如果真的为空则必须转入异常处理器中恢复并抛出NullPointException异常，这个过程必须从用户态转到内核态中处理，结束后再回到用户态，这个速度远比一次判空慢
  * 如果foo极少为空，这种隐式异常优化是值得的，这个选择策略JVM会自动选择

```
if(foo!=null){
    return foo.value;
}
else{
    throw new NullPointException();
}
//使用隐式异常优化后的代码
try{
    return foo.value;
}
catch(segment_fault){
    uncommon_trap();
}
```

* 逃逸分析

  * 分析对象动态作用域：对象在方法中被定义后，如果一个对象作为调用参数传递到其他方法中，称为方法逃逸，甚至还有可能被外部线程访问到，比如赋值给类变量等，称为线程逃逸

  * 如果能证明一个对象不会逃逸到方法或线程之外，就可能为这个变量进行一些高效的优化

    * 栈上分配：如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很不错的 主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对 象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁 了，垃圾收集系统的压力将会小很多。 

    * 同步消除：线程同步本身是一个相对耗时的过程，如果逃 逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就 不会有竞争，对这个变量实施的同步措施也就可以消除掉。 

    * 标量替换：如果把一个Java对象拆散， 根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换。那程序真正执行的时 候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代 替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会 被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优 化手段创建条件。 

      